# Mini Minecraft Video Demo: https://youtu.be/R0v2h4KRhII
As part of a three-member team, collaboratively designed and developed a C++ game engine using OpenGL and Qt Creator, focused on procedural terrain generation, efficient chunking, and real-time rendering. Implemented Perlin noise-based algorithms for terrain and biome generation, including cave systems and diverse biomes with custom features. Utilized multithreading to optimize terrain generation and VBO preparation, ensuring smooth gameplay during dynamic terrain expansion. Contributed to the development of a physics engine with precise collision detection using ray-casting, supporting both flight and non-flight player movement. Integrated advanced texturing techniques, including UV mapping and water animation, and built a responsive GUI inventory system for real-time block management.


# Gayeon 
## Procedural Terrain
I used the terrain visualizer to test out the noise functions
The offset was made with fbm, and the terrain was created with perlin noise with the block's x and z coordinates and offset as parameters. 
The grassland only used the floor function, and the mountain terrain used an additional smoothstep function to create the steep mountains. 
Function used to blend the biomes was also created using the Perlin noise and the mix function.

## Cave Generation
I used Perlin function to generate caves, similar to what I did for milestone 1. When the result is negative, the block is set to either empty or lava.
I also had to adjust the noise parameters a lot so that the hollow spaces actually look like caves, not some blocks randomly removed underground. I also implemented post processing in mygl.cpp, which is triggered when the player is under water/lava.

## Additional Biomes + a
Added two new biomes that are procedurally generated similar to milestone 1.
I used two values(temperature, extremeness) to interpolate between four biomes(grassland, desert, mountains, iceland), which are generated with perlin noise.  
For each biome, there are features that make the biomes look more interesting.
- grassland: flowers, trees
- mountains: mushrooms, mushroom trees
- desert: bushes, cacti, pyramids
- iceland: water generated instead of land, icebergs and patches of ice floating on top  

  
All of the features are generated with different applications of perlin noise. But since perlin noise is continuous, the trees were drawing on top of each other, so I had to check surrounding blocks to generate trees so that they have some space between them(same goes for mushroom trees, cacti, and pyramids).  

The trees shapes are randomly generated by using random function I implemented in milestone 1: each corner of the leaves do not get generated with 50% chance. Size of the pyramids are also different, as well as the tree height, and cactus height; all generated with perlin noise.
I also changed how the snow is formed: instead of having it uniformly start at y = 200, I used perlin noise to make it look more natural. 


# Tian
## Efficient Terrain Rendering and Chunking
I started implementing the generation of VBO data to include only the exposed faces and also using an interleaved buffer but I was stuck on a bug at time of submission (I posted ed post https://edstem.org/us/courses/53714/discussion/4730821).

I also started creating another draw function in the shader program and the function to determine whether a new chunk needs to be generated but could not progress that far without fixing my bug.

edit: attended many office hours sessions - spoke to Logan, Saksham, Zhen and Zhanbo to name a few - to fix the bugs I was encountering and clarify my approach.
I ended up implementing a function called terrainExpansion() which is called in the MyGL tick function before the terrain is actually drawn. This checks whether all the chunks within a given radius of the player have been generated and if they haven't, creates their VBO data and adds the chunk to the terrain's chunk store.
Then, in the actual renderTerrain function that gets called later in the tick, we just need to send this data to the shader program, which has now been set up process an interleaved buffer rather than separate buffers for pos, nor and col.

## Texturing
I started implementing texturing, but came up with an issue where the terrain just renders black and there is one warning showing that says the png file is not an known sRGB format. Tried manually changing the fs_UV value in the shader program, but the colour of the blocks didn't change. So, not exactly sure where the error is occuring - if it's with loading in the image or somewhere else with setting up the connections between handles and textures etc. Currently trying to get assistance with this issue in office hours.

update: it ended up being an issue with not loading the texture in / binding after creation.
Then just created an offset map like Adam had in the lecture to map uv coordinates to textures in the texture map. Also adjusted the adjacentBlocks to account for the offsets of an indiviual block's vertices.

Then used a similar time based adjustment to what Adam had in the lecture to animate water and lava by just moving the uv coordinates down the texture map based on a time variable.

## Water animation
Adjusted the vertex shader to adjust the y position based on a sinusoidal curve and time then added a blinn-phong highlight to the fragment shader.
Tried to adjust the normals based on this as well but that didn't work. Also tried then using fbm to effect normals like Adam had done in the lecture so had to just create some distortions in x and y by naively adding a layer of noise - Jiangxu from office hours helped with this. He also helped with fixing a bug in which the reflections shifted based on my position rather than the water's position (fixed by using fs_Pos rather than gl_FragCoord to calculate normals).

Also had issues with the blinn-phong initially looking like static. After office hours with Zhanbo, discovered it had to do with barycentric interpolation done by glsl so relaxed the bounds of the check for the animatable flag I added to the z coord of UV.

# Ashley
## Game Engine Tick Function and Player Physics
I implemented the player movement in flight mode and non-flight mode with the WASD keys 
The rotation of looking around was implemented with the arrow keybinds due to limitations of moveMouseToCenter() on the Mac. 
Gravity is implemented in non-flight mode to allows player to jump up and fall back down.
Ray casting is used with gridMarch function for collision detection forwards and downwards.
- Forward collision detection is checked from the player's 12 corner points
- Downward collision detection is checked from the player's 4 feet corner points

## Multithreading 
I implemented multithreading in our game to enhance performance during terrain generation. Each game frame, the program checks a 10x10 terrain generation zone around the player and generates new terrain where needed. This is managed by spawning BlockTypeWorkers to fill new zones with procedural block data and VBOWorkers to prepare VBO data for rendering, though only the main thread handles GPU communication. To coordinate data across threads, I used mutexes to protect shared resources, ensuring thread-safe operations without collisions or memory issues. This setup efficiently manages the dynamic terrain expansion, maintaining smooth gameplay even as new chunks are generated and rendered.

## GUI inventory
I created a new widget to keep track of the blocks that the player has and the current block selection. By default the player has 10 of each block at the start. The GUI opens and closes with the 'I' button. The GUI keeps track of the quantity of each block, and each time we remove/create a block the quantities are updated so that we can only place blocks that we have.
